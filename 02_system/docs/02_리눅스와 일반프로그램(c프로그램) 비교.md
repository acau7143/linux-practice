# 리눅스와 일반프로그램(c프로그램) 비교


## 실습 : 리눅스도 c 프로그램과 같은 하나의 c언어 프로그램(vmlinux) 임을 확인하자

## cpu는 끊임없이 함수를 실행한다.(백지위에서 그려낼 만큼 이해도를 가져야 함) 이런 흐름을 가지고 있어야 문제 해결할 때 편하다.

```
1. 유저 함수 (예 : mysql)

2. 라이브러리 함수 (예 : libc)

****커널 함수는 언제 왜 호출이 될까?** (이론으로 공부한 사람은 잘 대답 못함)**
3. 커널 함수
Entry(부팅 이후에 갑자기 호출되는 경우)  
	1) 예외처리 : 시스템 콜 (why 유저 프로그램이 hw 자원이 필요할 때), 페이지 폴트 등
	2) 인터럽트 : 네트워크 패킷 도착 , usb 연결 , ssd 디스크 I/O 끝난 상황, ...
	
	3) 커널태스크(커널스레드) : ksoftirqd, kworker, ... (후반부 작업)
	
라이브러리 함수와 유저함수가 cpu 점유율이 이상적으로 높다.
커널 함수는 서포트 해줌 
```


## 면접에서 이렇게 답하면 좋음

> 커널 함수는 직접 호출할 수 없으며, 세 가지 경우에 커널이 직접 진입합니다.
> 
> 
> 첫째, 유저/라이브러리 함수가 **하드웨어 자원 접근**을 요청할 때 → 시스템 콜 발생
> 
> 둘째, **예외 상황**이 발생하거나 인터럽트가 도착하면 → 커널이 ISR을 통해 대응
> 
> 셋째, **커널 내부 백그라운드 작업**(예: 메모리 관리, 스케줄링 등)을 위해 커널 스레드가 주기적으로 호출됩니다.
> 
> 이 과정에서 커널 함수는 사용자 요청을 처리하거나 시스템 상태를 유지하는 데 필수적인 역할을 합니다.
> 

```
커널은 c 프로그램이다. 실체적인 측면이라 봤을 떄는 매한가지이다.
어떤 차이점과 공통점이 있는지 알아보자

리눅스 커널 소스 코드 
cd ~/git/linux

리눅스 kernel은 추상적인 측면이 심하다. 그러지 말고 실체를 명확하게 보면 명확하게 접근이 가능하다.

우리가 사용하는 유저 프로그램이나 kernel 프로그램이나 별반 다르지 않다. 다만 역할 적인 측면에서는 차이가있다. memory에 올라와서 작동하는 건 똑같지만

```

## 💡 CPU, Memory, Disk를 활용한 소프트웨어 동작 과정

---

### 🟢 1. **디스크(Disk) - 저장소**

- 역할: 소프트웨어(프로그램), 데이터, 운영체제 등을 **영구 저장**
- 프로그램 설치 파일이나 실행 파일은 **디스크에 저장된 상태**임

📌 예시:

- `파이썬.exe`, `게임 프로그램`, `워드 파일` 등은 디스크(HDD/SSD)에 저장됨

---

### 🟡 2. **메모리(RAM) - 작업 공간**

- 역할: **실행 중인 프로그램을 임시로 저장**하는 공간
- 디스크에 있던 프로그램이 실행되면 → **RAM으로 복사되어 로딩**
- CPU가 작업할 데이터와 명령어는 모두 RAM에 있어야 실행 가능

📌 특징:

- 속도 빠름 (디스크보다 수십~수백 배 빠름)
- 전원 꺼지면 내용 사라짐

---

### 🔴 3. **CPU - 계산/명령 처리 장치**

- 역할: 실제 **명령어를 실행**하고 **연산을 수행**하는 두뇌
- RAM에서 명령어와 데이터를 가져와 → 해석하고 → 실행함
- 소프트웨어가 동작하는 핵심 처리기

- **Fetch (가져오기)**: 메모리에서 명령어를 가져옴
- **Decode (해독하기)**: 명령어를 해석
- **Execute (실행하기)**: 연산 수행, 입출력, 데이터 이동 등

📌 예시:

- `print("Hello")`를 실행할 때, CPU가 `print` 명령을 해석하고 화면에 출력

---

## 🔁 전체 흐름 요약

```
📦 디스크(HDD/SSD)
      ↓ (프로그램 실행)
📥 메모리(RAM)
      ↓ (CPU가 명령어 가져옴)
⚙️ CPU → 실제 처리
```

---

## 🎮 예시: 게임 실행 흐름

1. **게임 실행 아이콘 클릭** → 디스크에 있는 실행 파일이 실행됨
2. OS가 게임 프로그램을 **RAM에 적재**
3. CPU가 **RAM의 명령어와 데이터를 읽어 처리**
4. 게임 그래픽 처리, 입력 감지, 사운드 등은 CPU가 처리
5. 결과(화면 출력)는 모니터, 사운드는 스피커로 전송됨
6. 게임 종료 시 RAM에서 제거되고 CPU도 작업 종료

### 실제 리눅스에서 확인해보기

```bash
$ echo $$
1164

# 현재 프로세스 PID 1164 기준으로
# 가상메모리 주소공간을 어떻게 나눠서 쓰고 사용중인지 파악가능
$ cat /proc/1164/maps
55c54eb8a000-55c54ec8e000 r-xp 00000000 08:02 131100                     /bin/bash 
55c54ee8d000-55c54ee91000 r--p 00103000 08:02 131100                     /bin/bash
55c54ee91000-55c54ee9a000 rw-p 00107000 08:02 131100                     /bin/bash
55c54ee9a000-55c54eea4000 rw-p 00000000 00:00 0
55c54f48d000-55c54f60f000 rw-p 00000000 00:00 0                          [heap]
...
7fff9f2e2000-7fff9f303000 rw-p 00000000 00:00 0                          [stack]

# 지금 실행하는 cat 프로세스 기준으로: self (현재 실행중인 프로세스 PID 대신사용)
# 가상메모리 주소공간을 어떻게 나눠서 쓰고 사용중인지 파악가능
$ cat /proc/self/maps
```

## ✅ **운영체제(OS) & 커널 개념 중 꼭 알아야 할 핵심들**

### 🔹 1. 유저 공간 vs 커널 공간

| 개념 | 쉽게 말하면 |
| --- | --- |
| **유저 공간** | 우리가 만든 프로그램(Python, C 등)이 실행되는 공간 |
| **커널 공간** | OS(운영체제)가 실행되는 공간. 하드웨어 제어도 여기서 함 |
| ❗ 중요 포인트 | 유저 프로그램은 하드웨어에 직접 접근 ❌ → OS한테 부탁함 (시스템 콜) |

---

### 🔹 2. 시스템 콜 (System Call)

| 개념 | 쉽게 말하면 |
| --- | --- |
| 시스템 콜 | 유저 프로그램이 OS에게 “도와줘!” 하고 요청하는 문 |
| 예시 | `read()`, `write()`, `open()`, `fork()` 등 |
| 흐름 | 유저 코드 → 라이브러리 함수 → 시스템 콜 → 커널 함수 |
| ❗ 핵심 | 하드웨어 접근할 땐 무조건 시스템 콜 통해야 함 |

---

### 🔹 3. 페이지 폴트 (Page Fault)

| 개념 | 쉽게 말하면 |
| --- | --- |
| 페이지 폴트 | 프로그램이 아직 메모리에 없는 데이터를 쓰거나 읽을 때 발생 |
| 상황 | 배열 10억 번째를 읽었는데 메모리에 없음 → OS가 디스크에서 불러옴 |
| 결과 | OS가 RAM에 올려주고 다시 실행 → 사용자는 모름 |
| ❗ 핵심 | 메모리를 효율적으로 쓰기 위한 "지연 로딩" 방식의 일부 |

---

### 🔹 4. 인터럽트

| 개념 | 쉽게 말하면 |
| --- | --- |
| 인터럽트 | 하드웨어가 CPU에게 “야, 나 일 끝났어!”라고 알림 |
| 예시 | 마우스 클릭, 디스크 작업 완료, 네트워크 수신 등 |
| ❗ 핵심 | CPU는 대기하지 않고, 인터럽트로 이벤트만 받아 처리함 |

---

### 🔹 5. 커널 스레드 (예: `kworker`, `ksoftirqd`)

| 개념 | 쉽게 말하면 |
| --- | --- |
| 커널 스레드 | OS 내부에서 자동으로 돌아가는 작업들 |
| 예시 | `kworker`: 일감 처리 / `ksoftirqd`: 네트워크 처리 등 |
| ❗ 핵심 | top 명령어 등에서 CPU 점유율이 높을 수 있는데, 이게 문제 상황의 힌트가 되기도 함 |