# Stack 메모리 공간 할당 세부 분석


### 한 줄 핵심

컴파일러가 스택을 **32바이트**로 맞춰도, OS는 메모리를 **4KB(4096바이트) 페이지**로만 붙여줘서 **물리 메모리 낭비가 거의 없다**는 뜻이야.

### 왜 그런가?

1. **정렬(Alignment) 때문에 32바이트**
    
    `int` 5개=20B지만, CPU가 빠르게 접근하도록 **32B**로 “모양”만 맞춰 둠.
    
2. **OS는 4KB 단위로만 메모리를 준다**
    
    스택에서 20B를 쓰든 32B를 쓰든, 둘 다 **같은 4KB 페이지** 안에서 일어남.
    
    → 12B 패딩이 “새 페이지”를 더 쓰게 만들지 않음.
    

1. **실제 물리 메모리는 접근할 때만 매핑**(demand paging)
    
    스택에 기록하는 순간 그 페이지 4KB가 물리 메모리에 붙고, 그 안에서 20B를 쓰든 32B를 쓰든 **추가 비용 동일**.
    

### 비유

- **페이지(4KB) = 큰 박스 1개**
- 그 박스 안에 물건을 20개 넣든 32개 넣든 **박스는 똑같이 1개**야.
    
    박스를 하나 더 받는 게 아니니 “낭비 아님”.
    

### 주의할 점

- 스택이 아주 많이 커져서 **다음 4KB 경계를 넘을 때**만 새 페이지가 붙음.
    
    (12B 패딩 때문이 아니라, 어차피 크기가 커져서 넘는 거!)
    

결론 👉 32바이트로 맞춘 건 **성능/규약을 위한 정렬**이고, **물리 메모리**는 페이지(4KB) 단위라서 **실제 낭비로 이어지지 않는다**!