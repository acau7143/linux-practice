# 파일 디스크립터와 Open


# 흐름 요약 (비유: 전화번호부 인덱스)

- **유저 프로그램(그림의 mysql)** 이 `int fd = open("hello.txt", ...)` 를 호출하면 → **시스템콜**로 커널에 내려갑니다.
- 커널은 그 프로세스의 **task_struct**(프로세스 상태 정보) 안에 있는 **FD 테이블(fd table)** 에 새 칸을 하나 잡고 거기에 **핸들**을 꽂아요.
    - FD(파일 디스크립터)는 “작은 숫자 인덱스”예요.
    - 0,1,2는 보통 **stdin, stdout, stderr**라서 이미 차지되어 있고, **다음 빈 칸이 3**이어서 그림처럼 `[3]`에 들어가요. 그래서 `open()`의 반환값이 3이 될 수 있어요.

- 이 FD 테이블의 칸에는 커널 객체인 **`struct file`** 를 가리키는 포인터가 저장됩니다.
    - 즉, **유저 공간에서는 ‘숫자(fd)’만**, **커널 내부에서는 실제 상태가 들어 있는 `struct file`** 로 연결돼요.
- 이후 `write(fd, ...)` 를 하면:
    1. 커널이 **fd 숫자 → FD 테이블**에서 찾아서
    2. 그 칸에 있는 포인터로 **`struct file`** 에 도달하고
    3. 그 `struct file` 이 가리키는 실제 파일(디렉토리 엔트리/아이노드 등)에 **쓰기 작업**을 해요.

# 각 요소가 하는 일

- **fd (파일 디스크립터)**: 유저 프로그램이 들고 다니는 **작은 번호표**. (전화번호부의 “인덱스 번호” 느낌)
- **FD 테이블 (per-process)**: 그 프로세스만의 **번호표 → 실제 커널 객체** 매핑 표. `task_struct → files` 안에 있어요.
- **`struct file` (커널 객체)**: 파일의 **현재 오프셋(파일 포인터), 열기 플래그(O_RDONLY 등), 권한, 캐시된 상태** 같은 **진짜 실행 정보**를 품고 있어요. (전화번호부의 “실제 연락처 카드”)

# 자주 묻는 포인트

- **왜 fd가 3부터 나와요?**
    
    0,1,2는 표준 입출력/오류가 기본으로 열려 있어서 그다음 빈 칸이 3이기 때문.
    
- **프로세스마다 FD 테이블은 따로?**
    
    네. **프로세스마다** 자기만의 FD 테이블이 있어요. (다만 `fork()`로 만든 자식은 처음에 부모와 같은 “참조”를 공유합니다.)
    
- **`dup()`/`fork()` 하면?**
    
    서로 다른 **fd 숫자**가 **같은 `struct file`** 을 가리킬 수 있어요(참조 카운트 증가). 그래서 파일 오프셋이 함께 움직일 수도 있습니다.
    
- **`close(fd)` 하면?**
    
    FD 테이블의 그 칸을 비우고(`struct file` 참조 감소), 더 이상 그 번호로 접근 못 해요.
    

요약:

`open()` → **내 FD 테이블의 빈 칸(예: 3번)에 `struct file` 포인터를 꽂고** 그 **번호(3)** 를 돌려준다 → `write(3, ...)` 같은 다음 호출에서 커널은 **3 → `struct file`** 을 찾아 실제 파일 작업을 수행한다… 이렇게 이해하면 됩니다.

---

`task_struct` = **리눅스 커널이 “프로세스/스레드 한 개”를 표현하는 구조체(신분증 + 생활기록부)**

쉽게 말해, 커널 입장에서 어떤 프로세스를 관리하려면 “그 프로세스의 모든 상태”를 어딘가에 저장해야 하잖아요? 그 “한 덩어리”가 바로 `task_struct`예요.

# 한눈 요약

- **하나의 실행 단위(스레드)** 당 **`task_struct` 1개**
    - 리눅스는 프로세스도 내부적으로 스레드처럼 다뤄서, 프로세스의 각 스레드마다 `task_struct`가 있어요.
- 여기에 **스케줄링 정보, 메모리, 파일 테이블, 시그널, 권한** 등 해당 태스크의 모든 관리 정보가 들어있어요.

---

![image.png](../images/15_1.png)

# 한 줄 요약

`open("…/uftrace")` → **경로명 해석(namei)**로 **inode** 찾기/만들기 → 그 inode와 연결된 **file 객체** 만들기 → 내 프로세스 **fd 테이블**에 꽂고 **정수 fd**를 반환.

# 단계별로 쓱 훑기

1. **사용자 → 커널 진입**
- 프로그램이 `open("/usr/local/bin/uftrace", O_RDONLY)` 호출 → 커널의 **`do_sys_open`*으로 들어감.
1. **경로명을 아이노드로 바꾸기 (namei)**
- `"/" → "usr" → "local" → "bin" → "uftrace"` 순서로 디렉터리를 내려가며 탐색.
- 이때 **dentry 캐시**(디렉터리 엔트리 캐시)를 먼저 보고, 없으면 디스크에서 찾아 캐시에 넣음.
- 마지막 구성요소(파일 이름)까지 찾아서 **해당 파일의 inode**를 얻음.
    - `O_CREAT`가 있고 파일이 없으면 **새 inode 생성**(그림의 “파일 아이노드 생성”).
1. **file 객체 만들기 (커널의 열린-파일 상태)**
- 커널은 **file 객체**를 하나 생성하고, 방금 찾은 **inode**에 연결함.
- file 객체에는 “열기 모드(읽기/쓰기)”, “현재 오프셋(파일 포인터)”, “플래그(O_APPEND 등)” 같은 **‘열린 상태’**가 저장됨.
    - 중요: **inode는 ‘무엇’(파일 자체)**, **file 객체는 ‘어떻게 열었는지’(세션)**.
1. **파일 디스크립터(fd) 배정**
- 내 프로세스의 **fd 테이블(fdtable)**에서 빈 칸(가장 작은 번호)을 하나 고름.
- 그 칸에 방금 만든 **file 객체의 포인터**를 꽂음.
- 그 칸의 번호(예: 3, 4 …)를 **정수 fd**로 **리턴**.
1. **사용자는 정수만 받음**
- 사용자 입장에선 `int fd = open(...);` 처럼 **숫자**만 받지만, 커널 안쪽에선
    
    `fd → fdtable[fd] → file 객체 → inode` 이렇게 따라가서 실제 파일에 도달해.
    

# 키워드 미니 용어집

- **namei**: “**이름(name)** → **inode**”로 바꾸는 경로 해석 엔진.
- **dentry(디엔트리) 캐시**: “이 디렉터리에서 이 이름이면 저 inode” 같은 **이름→inode 매핑 캐시**. 경로 탐색을 빠르게 함.
- **inode**: 파일의 정체성/메타데이터(권한, 소유자, 크기, 블록 위치…). **파일 그 자체**.
- **file 객체(struct file)**: “이번에 연 이 파일의 세션 정보”(모드, 오프셋 등). **열 때마다 새로 생김**.
- **fd(파일 디스크립터)**: 사용자 공간에서 쓰는 **정수 핸들**. `read(fd, …)`처럼 호출할 때 전달.
- **fd 테이블**: 프로세스마다 있는 **정수 → file 객체 포인터** 배열.

# 자주 헷갈리는 포인트

- **inode vs file 객체**
    - inode: 하나의 파일에 1개(파일마다 고유).
    - file 객체: `open()` 할 때마다 1개(프로세스/스레드마다 다를 수 있음).
- *fd는 값(숫자)**일 뿐이고, 실제 실체는 fdtable에 꽂힌 **file 객체**.
- “파일 아이노드 생성”은 `O_CREAT` 등 **생성 플래그**일 때만. 기존 파일 열면 생성 안 함.

---

# 경로 해석과 fd까지 (VFS가 하는 일)

`open("/usr/…/index.html")`

1. **namei**가 dentry 캐시/디스크 보고 경로를 **inode**로 해석
2. 그 inode로 **file** 객체 생성(열기 모드/오프셋 등 기록)
3. 내 프로세스 **fd 테이블**에 꽂고 **정수 fd** 리턴

# “소켓도 fd”가 되는 이유 (VFS 덕분)

- 소켓은 디스크에 있는 파일은 아니지만, **inode 타입 중 하나(소켓)** 로 다뤄지고,
    
    그에 맞는 **file_operations**(send/recv 등)로 연결돼.
    
- 그래서 사용자 공간에선 **소켓도 그냥 fd**. `read/write/poll/epoll` 같은 **같은 인터페이스**를 그대로 사용 가능.

# 왜 중요한가

- **추상화 통일**: 파일·파이프·소켓·장치를 같은 방식으로 다룰 수 있어 코드가 단순해짐.
- **성능 트릭 가능**: `sendfile`, `splice`, `mmap` 같은 고급 API를 VFS가 매개하여 **복사 감소·컨텍스트 스위치 감소**.
- **플러그형 설계**: ext4↔NFS↔tmpfs를 바꿔도 위의 앱 코드는 그대로 동작.

# 기억할 문장

> “리눅스에서 모든 것은 파일이고, 그걸 가능하게 하는 커널의 공용 어댑터가 VFS다.
> 
> 
> 소켓이 fd로 보이는 이유도, 정적 파일을 소켓으로 빠르게 보내는 것도 **VFS 추상화** 덕분.”
>